import os
import pandas as pd
import numpy as np
from matplotlib import pyplot as plt


def explore_labels_classification():
    df = pd.read_csv("trainLabels.csv")
    id_, classification_column = df.columns
    grouped = df.groupby(classification_column).count()
    grouped.rename(columns={'Id': "NumberOfMalware"}, inplace=True)
    pd.DataFrame(grouped).to_csv("stats_of_dataset.csv")


def calculate_percent():
    df = pd.read_csv("stats_of_dataset.csv")
    sum_of_malware = df['NumberOfMalware'].sum()
    df['Percentages'] = ((df['NumberOfMalware'] / sum_of_malware) * 100).round(decimals=2)
    pd.DataFrame(df).to_csv("stats_of_dataset.csv", index=False)

    x = df['Class'].values
    y = df['Percentages'].values

    plt.bar(x, y, edgecolor="red", color='black')
    axy = plt.subplot()
    axy.set_xticks(x)
    # axy.set_yticks(np.arange(0, 100, 10, dtype=int))
    plt.xlabel("Malware Class")
    plt.ylabel("Percantage of occurence [%]")
    plt.show()


def file_size_malware_type():
    def coroutine_decorator(func):
        def wrap(*args, **kwargs):
            cr = func(*args, **kwargs)
            next(cr)
            return cr
        return wrap

    @coroutine_decorator
    def get_size_of_file(func=None):
        try:
            while True:
                path_file = yield
                size = os.path.getsize(path_file)
                func.send(f"{size} {path_file}")
        except GeneratorExit:
            print("Closed! get_size")

    @coroutine_decorator
    def apply_the_size():
        try:
            while True:
                size_file = yield
                size, file = size_file.split(" ")
                # file = file.rsplit("/", maxsplit=1)[-1]
                df.loc[file, "Bytes"] = size
        except GeneratorExit:
            print("Closed! apply_the_size")


    PATH = "bytes_raw"

    df = pd.read_csv("trainLabels.csv")
    # chdir was used due to limitation of windows path
    os.chdir(os.path.dirname(f"./{PATH}/"))
    df.set_index('Id', inplace=True)
    df['Bytes'] = np.nan
    # print(df.loc["04EjIdbPV5e1XroFOpiN"]['Bytes'])
    bytes_raw = os.listdir(".")
    print(bytes_raw)
    gsf = get_size_of_file(apply_the_size())
    for malware in bytes_raw:
        gsf.send(malware)
    print(df)
    os.chdir(os.path.dirname("../"))
    pd.DataFrame(df).to_csv("Malware_class_bytes.csv", index=True)


import os
import shutil
import asyncio
import aiofiles
import sys
from time import perf_counter
from PIL import Image

import pandas as pd
import numpy as np
from tqdm import tqdm


DIRECTORY_TO_PROCESS = "train/"
DIRECTORY_TO_WRITE = "bytes_raw/"
files_to_process = os.listdir("train")

processed_files_bytes_raw = os.listdir("bytes_raw")

def entry_process_file(path_to_process: str, path_to_write: str, filenames: list[str]):
    with tqdm(total=len(filenames), desc="Entry preprocessing: ") as bar:
        if not os.path.exists(path_to_write):
            os.makedirs(path_to_write)

        for filename in filenames:
            filename_to_write = filename.split(".")[0]
            file_to_write = open(f"{path_to_write}{filename_to_write}", mode="w+")
            with open(f"{path_to_process}{filename}", mode="rb") as file_handler:
                read_file = file_handler.read().decode().splitlines()
                for line in read_file:
                    if "?" in line:
                        continue
                    line_to_write = " ".join(line.split()[1:])
                    file_to_write.write(f"{line_to_write}\n")
                file_to_write.close()
                bar.update(1)


def coroutine_decorator(func):
    def wrap(*args, **kwargs):
        cr = func(*args, **kwargs)
        next(cr)
        return cr
    return wrap


def directories_with_files_per_class():
    @coroutine_decorator
    def file_category(func=None):
        try:
            while True:
                malware_file = yield
                category_of_malware = files_class.get(malware_file)
                destination = f"{DIRECTORY_AGGREGATION_MALWARE}{category_of_malware}/{malware_file}"
                func.send(destination)
        except GeneratorExit:
            print("Closing! file_category")

    @coroutine_decorator
    def copy_aggregation_malware():
        try:
            while True:
                dest_path = yield
                malware_file = dest_path.rsplit("/", maxsplit=1)[-1]
                shutil.copy(f"bytes_raw/{malware_file}", dest_path)
        except GeneratorExit:
            print("Closing! aggregation")


    DIRECTORY_AGGREGATION_MALWARE = "malware_types_aggregated/"

    df = pd.read_csv("trainLabels.csv")
    df.set_index("Id", inplace=True)
    files_class = df.to_dict()['Class']
    classes_of_malware = set(map(lambda number: f"{number}", files_class.values()))
    if not os.path.isdir(DIRECTORY_AGGREGATION_MALWARE):
        os.makedirs(DIRECTORY_AGGREGATION_MALWARE)

    {os.makedirs(f"{DIRECTORY_AGGREGATION_MALWARE}{directory}") for directory in classes_of_malware
                                    if not os.path.isdir(f"{DIRECTORY_AGGREGATION_MALWARE}{directory}")}

    fc = file_category(copy_aggregation_malware())
    byte_files = os.listdir('bytes_raw')
    with tqdm(total=len(byte_files), desc="Aggregation of malware: ") as bar:
        for byte_file in byte_files:
            fc.send(byte_file)
            bar.update(1)


def process_to_int():
    @coroutine_decorator
    def parse_to_int(func=None):
        try:
            while True:
                hex_line = yield
                digits_hex = line.split()
                digits_int = [str(int(digit, 16)) for digit in digits_hex]
                func.send(digits_int)
        except GeneratorExit:
            print("Parse_to_int - closing!")

    @coroutine_decorator
    def write_line():
        try:
            while True:
                digits_int = yield
                file_write_handler.write(f"{' '.join(digits_int)}\n")
        except GeneratorExit:
            print("Write_line - closing!")

    DIRECTORY_AGGREGATION_MALWARE_INT = "malware_types_aggregated_int/"

    df = pd.read_csv("stats_of_dataset.csv")
    files_class = df.to_dict()['Class']
    classes_of_malware = set(map(lambda number: f"{number}", files_class.values()))
    {os.makedirs(f"{DIRECTORY_AGGREGATION_MALWARE_INT}{directory}") for directory in classes_of_malware
     if not os.path.isdir(f"{DIRECTORY_AGGREGATION_MALWARE_INT}{directory}")}

    number_of_malware = df['NumberOfMalware'].sum()
    pti = parse_to_int(write_line())
    with tqdm(total=number_of_malware, desc="Converting hex values into int: ") as bar:
        for root, dirs, files in os.walk("malware_types_aggregated\\"):
            root_ = root
            for file in files:
                file_read = os.path.join(root_, file)
                directory, category, file = file_read.split("\\")
                directory = f"{directory}_int"
                file_write = os.path.join(directory, category, file)
                file_write_handler = open(file_write, mode="w+")
                with open(file_read, mode="r") as file_read_handler:
                    for line in file_read_handler:
                        pti.send(line)
                file_write_handler.close()
                bar.update(1)


async def write_images():
    async def async_save_img(async_save):
        await async_save

    DIRECTORY_AGGREGATION_MALWARE_IMAGES = "malware_types_aggregated_images/"
    DIRECTORY_AGGREGATION_MALWARE_INT = "malware_types_aggregated_int/"

    df = pd.read_csv("stats_of_dataset.csv")
    files_class = df.to_dict()['Class']
    classes_of_malware = set(map(lambda number: f"{number}", files_class.values()))
    {os.makedirs(f"{DIRECTORY_AGGREGATION_MALWARE_IMAGES}{directory}") for directory in classes_of_malware
     if not os.path.isdir(f"{DIRECTORY_AGGREGATION_MALWARE_IMAGES}{directory}")}
    number_of_malware = df['NumberOfMalware'].sum()
    with tqdm(total=number_of_malware, desc="Converting int into img: ") as bar:
        for root, dirs, files in os.walk(DIRECTORY_AGGREGATION_MALWARE_INT):
            for file in files:
                filename = f"{root}/{file}"
                async with aiofiles.open(filename) as f:
                    content = await f.read()

                array = np.array(content.split(), dtype=np.uint8)
                data_image = Image.fromarray(array)
                data_image = data_image.resize((256, 256), resample=Image.NEAREST)
                _, category, file_to_write = filename.split("/")
                path_file_to_write = f"{DIRECTORY_AGGREGATION_MALWARE_IMAGES}{category}/{file_to_write}.png"
                bar.update(1)
                async_save_img(data_image.save(path_file_to_write))

async def run_write_images():
    await write_images()
if __name__ == "__main__":
    # entry_process_file(DIRECTORY_TO_PROCESS, DIRECTORY_TO_WRITE,files_to_process)
    # directories_with_files_per_class()
    # process_to_int()
    asyncio.run(run_write_images())

if __name__ == "__main__":
    # explore_labels_classification()
    # calculate_percent()
    file_size_malware_type()